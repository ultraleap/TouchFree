## API Report File for "touchfree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @internal
enum ActionCode {
    CONFIGURATION_FILE_RESPONSE = "CONFIGURATION_FILE_RESPONSE",
    CONFIGURATION_FILE_STATE = "CONFIGURATION_FILE_STATE",
    CONFIGURATION_RESPONSE = "CONFIGURATION_RESPONSE",
    CONFIGURATION_STATE = "CONFIGURATION_STATE",
    GET_TRACKING_STATE = "GET_TRACKING_STATE",
    HAND_DATA = "HAND_DATA",
    HAND_PRESENCE_EVENT = "HAND_PRESENCE_EVENT",
    INPUT_ACTION = "INPUT_ACTION",
    QUICK_SETUP = "QUICK_SETUP",
    QUICK_SETUP_CONFIG = "QUICK_SETUP_CONFIG",
    QUICK_SETUP_RESPONSE = "QUICK_SETUP_RESPONSE",
    REQUEST_CONFIGURATION_FILE = "REQUEST_CONFIGURATION_FILE",
    REQUEST_CONFIGURATION_STATE = "REQUEST_CONFIGURATION_STATE",
    REQUEST_SERVICE_STATUS = "REQUEST_SERVICE_STATUS",
    SERVICE_STATUS = "SERVICE_STATUS",
    SERVICE_STATUS_RESPONSE = "SERVICE_STATUS_RESPONSE",
    SET_CONFIGURATION_FILE = "SET_CONFIGURATION_FILE",
    SET_CONFIGURATION_STATE = "SET_CONFIGURATION_STATE",
    SET_HAND_DATA_STREAM_STATE = "SET_HAND_DATA_STREAM_STATE",
    SET_TRACKING_STATE = "SET_TRACKING_STATE",
    TRACKING_STATE = "TRACKING_STATE",
    VERSION_HANDSHAKE = "VERSION_HANDSHAKE",
    VERSION_HANDSHAKE_RESPONSE = "VERSION_HANDSHAKE_RESPONSE"
}

// @public
abstract class BaseInputController {
    constructor();
    disconnect(): void;
    protected HandleInputAction(_inputData: TouchFreeInputAction): void;
}

// Warning: (ae-internal-missing-underscore) The name "BitmaskFlags" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export enum BitmaskFlags {
    // (undocumented)
    CANCEL = 32,
    // (undocumented)
    DOWN = 64,
    // (undocumented)
    GRAB = 512,
    // (undocumented)
    HOVER = 1024,
    // (undocumented)
    LEFT = 1,
    // (undocumented)
    MOVE = 128,
    // (undocumented)
    NONE = 0,
    // (undocumented)
    NONE_INPUT = 16,
    // (undocumented)
    PRIMARY = 4,
    // (undocumented)
    PUSH = 2048,
    // (undocumented)
    RIGHT = 2,
    // (undocumented)
    SECONDARY = 8,
    // (undocumented)
    TOUCHPLANE = 4096,
    // (undocumented)
    UP = 256,
    // (undocumented)
    VELOCITYSWIPE = 8192
}

// @internal
class CommunicationWrapper<T> {
    constructor(_actionCode: ActionCode, _content: T);
    // (undocumented)
    action: ActionCode;
    content: T;
}

// @internal @deprecated
enum Compatibility {
    COMPATIBLE = 0,
    SERVICE_OUTDATED = 1,
    TOOLING_OUTDATED = 2
}

// @internal
class ConfigChangeRequest extends TouchFreeRequest {
}

// Warning: (ae-incompatible-release-tags) The symbol "ConfigState" is marked as @public, but its signature references "TouchFreeRequest" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "ConfigState" is marked as @public, but its signature references "TouchFreeRequest" which is marked as @internal
//
// @public
class ConfigState extends TouchFreeRequest {
    constructor(_id: string, _interaction: InteractionConfigFull, _physical: PhysicalConfig);
    interaction: InteractionConfigFull;
    physical: PhysicalConfig;
}

// @internal
class ConfigStateCallback extends TouchFreeRequestCallback<ConfigState> {
}

declare namespace Configuration {
    export {
        ConfigurationManager,
        InteractionConfig,
        InteractionConfigFull,
        HoverAndHoldInteractionSettings,
        TouchPlaneInteractionSettings,
        PhysicalConfig,
        Vector,
        Vector2,
        TrackedPosition
    }
}
export { Configuration }

// @public
class ConfigurationManager {
    static RequestConfigChange(_interaction: Partial<InteractionConfig> | null, _physical: Partial<PhysicalConfig> | null, _callback: (detail: WebSocketResponse) => void): void;
    static RequestConfigFileChange(_interaction: Partial<InteractionConfig> | null, _physical: Partial<PhysicalConfig> | null, _callback: (detail: WebSocketResponse) => void | null): void;
    static RequestConfigFileState(_callback: (detail: ConfigState) => void): void;
    static RequestConfigState(_callback: (detail: ConfigState) => void): void;
}

// @public
export enum ConfigurationState {
    ERRORED = 2,
    LOADED = 1,
    NOT_LOADED = 0
}

declare namespace Connection {
    export {
        ConnectionManager,
        MessageReceiver,
        ServiceConnection,
        ActionCode,
        HandPresenceState,
        Compatibility,
        HandPresenceEvent,
        TouchFreeRequestCallback,
        TouchFreeRequest,
        PartialConfigState,
        ConfigState,
        ConfigChangeRequest,
        HandRenderDataStateRequest,
        ConfigStateCallback,
        ServiceStatus,
        ServiceStatusRequest,
        ServiceStatusCallback,
        WebSocketResponse,
        VersionHandshakeResponse,
        ResponseCallback,
        CommunicationWrapper,
        SuccessWrapper,
        TrackingStateResponse,
        TrackingStateRequest,
        SimpleRequest,
        TrackingStateCallback
    }
}
export { Connection }

// @public
class ConnectionManager extends EventTarget {
    // @deprecated
    static AddConnectionListener(_onConnectFunc: () => void): void;
    // @deprecated
    static AddServiceStatusListener(_serviceStatusFunc: (serviceStatus: TrackingServiceState) => void): void;
    static Connect(): void;
    static Disconnect(): void;
    static GetCurrentHandPresence(): HandPresenceState;
    static HandleHandPresenceEvent(_state: HandPresenceState): void;
    static init(): void;
    static instance: ConnectionManager;
    static iPAddress: string;
    static get IsConnected(): boolean;
    // @internal
    static messageReceiver: MessageReceiver;
    static port: string;
    static RequestServiceStatus(_callback: (detail: ServiceStatus) => void): void;
    // @internal
    static serviceConnection(): ServiceConnection | null;
}

// Warning: (ae-internal-missing-underscore) The name "ConvertInputAction" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function ConvertInputAction(_wsInput: WebsocketInputAction): TouchFreeInputAction;

declare namespace Cursors {
    export {
        DotCursor,
        SVGCursor,
        TouchlessCursor
    }
}
export { Cursors }

// @public
export const DispatchEvent: <TEvent extends TouchFreeEvent>(eventType: TEvent, ...args: Parameters<TouchFreeEventSignatures[TEvent]>) => void;

// @public
class DotCursor extends TouchlessCursor {
    constructor(_cursor: HTMLElement, _cursorRing: HTMLElement, _animationDuration?: number, _ringSizeMultiplier?: number);
    readonly animationUpdateDuration: number;
    cursorRing: HTMLElement;
    // @internal
    GrowCursor(): void;
    // @internal
    HandleInputAction(_inputData: TouchFreeInputAction): void;
    HideCursor(): void;
    ringSizeMultiplier: number;
    ShowCursor(): void;
    // @internal
    ShrinkCursor(): void;
    // @internal
    UpdateCursor(_inputAction: TouchFreeInputAction): void;
}

// @public
export interface EventHandle {
    UnregisterEventCallback(): void;
}

// Warning: (ae-internal-missing-underscore) The name "FingerType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export enum FingerType {
    // (undocumented)
    TYPE_INDEX = 1,
    // (undocumented)
    TYPE_MIDDLE = 2,
    // (undocumented)
    TYPE_PINKY = 4,
    // (undocumented)
    TYPE_RING = 3,
    // (undocumented)
    TYPE_THUMB = 0,
    // (undocumented)
    TYPE_UNKNOWN = -1
}

// Warning: (ae-internal-missing-underscore) The name "FlagUtilities" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class FlagUtilities {
    static GetChiralityFromFlags(_flags: BitmaskFlags): HandChirality;
    static GetHandTypeFromFlags(_flags: BitmaskFlags): HandType;
    static GetInputTypeFromFlags(_flags: BitmaskFlags): InputType;
    static GetInteractionFlags(_interactionType: InteractionType, _handType: HandType, _chirality: HandChirality, _inputType: InputType): BitmaskFlags;
    static GetInteractionTypeFromFlags(_flags: BitmaskFlags): InteractionType;
}

// @public
export enum HandChirality {
    // (undocumented)
    LEFT = 0,
    // (undocumented)
    RIGHT = 1
}

// Warning: (ae-internal-missing-underscore) The name "HandFrame" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class HandFrame {
    // (undocumented)
    Hands: RawHand[];
}

// @internal
class HandPresenceEvent {
    constructor(_state: HandPresenceState);
    // (undocumented)
    state: HandPresenceState;
}

// @public
enum HandPresenceState {
    HAND_FOUND = 0,
    HANDS_LOST = 1,
    // @internal
    PROCESSED = 2
}

// @internal
class HandRenderDataStateRequest extends TouchFreeRequest {
    constructor(_id: string, enabled: boolean, lens: string);
    enabled: boolean;
    lens: string;
}

// @public
export enum HandType {
    PRIMARY = 0,
    SECONDARY = 1
}

// @public
interface HoverAndHoldInteractionSettings {
    HoverCompleteTimeS: number;
    HoverStartTimeS: number;
}

// @public
class InputActionManager extends EventTarget {
    // @internal
    static HandleInputAction(_action: TouchFreeInputAction): void;
    static get instance(): InputActionManager;
    static _instance: InputActionManager;
    static plugins: Array<InputActionPlugin> | null;
    static SetPlugins(_plugins: Array<InputActionPlugin>): void;
}

// @public
abstract class InputActionPlugin extends EventTarget {
    // @internal
    ModifyInputAction(_inputAction: TouchFreeInputAction): TouchFreeInputAction | null;
    RunPlugin(_inputAction: TouchFreeInputAction): TouchFreeInputAction | null;
    // @internal
    TransmitInputAction(_inputAction: TouchFreeInputAction): void;
}

declare namespace InputControllers {
    export {
        BaseInputController,
        WebInputController
    }
}
export { InputControllers }

// @public
export enum InputType {
    CANCEL = 1,
    DOWN = 2,
    MOVE = 3,
    NONE = 0,
    UP = 4
}

// @public
interface InteractionConfig {
    DeadzoneRadius: number;
    // (undocumented)
    HoverAndHold: Partial<HoverAndHoldInteractionSettings>;
    InteractionMaxDistanceCm: number;
    InteractionMinDistanceCm: number;
    InteractionType: InteractionType;
    InteractionZoneEnabled: boolean;
    // (undocumented)
    TouchPlane: Partial<TouchPlaneInteractionSettings>;
    UseScrollingOrDragging: boolean;
    UseSwipeInteraction: boolean;
}

// @public
interface InteractionConfigFull {
    // (undocumented)
    DeadzoneRadius: number;
    // (undocumented)
    HoverAndHold: HoverAndHoldInteractionSettings;
    // (undocumented)
    InteractionMaxDistanceCm: number;
    // (undocumented)
    InteractionMinDistanceCm: number;
    // (undocumented)
    InteractionType: InteractionType;
    // (undocumented)
    InteractionZoneEnabled: boolean;
    // (undocumented)
    TouchPlane: TouchPlaneInteractionSettings;
    // (undocumented)
    UseScrollingOrDragging: boolean;
    // (undocumented)
    UseSwipeInteraction: boolean;
}

// @public
export enum InteractionType {
    GRAB = 0,
    HOVER = 1,
    PUSH = 2,
    // (undocumented)
    TOUCHPLANE = 3,
    // (undocumented)
    VELOCITYSWIPE = 4
}

// @public
function MapRangeToRange(_value: number, _oldMin: number, _oldMax: number, _newMin: number, _newMax: number): number;

// @public
interface Mask {
    // (undocumented)
    left: number;
    // (undocumented)
    lower: number;
    // (undocumented)
    right: number;
    // (undocumented)
    upper: number;
}

// @internal
class MessageReceiver {
    constructor();
    actionCullToCount: number;
    actionQueue: Array<WebsocketInputAction>;
    callbackClearTimer: number;
    CheckForAction(): void;
    CheckForConfigState(): void;
    CheckForHandData(): void;
    CheckForResponse(): void;
    CheckForServiceStatus(): void;
    CheckForTrackingStateResponse(): void;
    ClearUnresponsivePromises(): void;
    configStateCallbacks: {
        [id: string]: ConfigStateCallback;
    };
    configStateQueue: Array<ConfigState>;
    HandleTrackingStateResponse(trackingStateResponse: TrackingStateResponse): void;
    lastKnownCursorPosition: Array<number>;
    lastStateUpdate: HandPresenceState;
    latestHandDataItem?: ArrayBuffer;
    responseCallbacks: {
        [id: string]: ResponseCallback;
    };
    responseQueue: Array<WebSocketResponse>;
    serviceStatusCallbacks: {
        [id: string]: ServiceStatusCallback;
    };
    serviceStatusQueue: Array<ServiceStatus>;
    trackingStateCallbacks: {
        [id: string]: TrackingStateCallback;
    };
    trackingStateQueue: Array<TrackingStateResponse>;
    Update(): void;
    updateRate: number;
}

// @internal
class PartialConfigState extends TouchFreeRequest {
    constructor(_id: string, _interaction: Partial<InteractionConfig> | null, _physical: Partial<PhysicalConfig> | null);
    interaction: Partial<InteractionConfig> | null;
    physical: Partial<PhysicalConfig> | null;
}

// @public
interface PhysicalConfig {
    LeapPositionRelativeToScreenBottomM: Vector;
    LeapRotationD: Vector;
    ScreenHeightM: number;
    ScreenHeightPX: number;
    ScreenRotationD: number;
    ScreenWidthPX: number;
}

declare namespace Plugins {
    export {
        InputActionManager,
        InputActionPlugin
    }
}
export { Plugins }

// Warning: (ae-internal-missing-underscore) The name "RawBone" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class RawBone {
    // (undocumented)
    NextJoint: Vector;
    // (undocumented)
    PrevJoint: Vector;
}

// Warning: (ae-internal-missing-underscore) The name "RawFinger" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class RawFinger {
    // (undocumented)
    Bones: RawBone[];
    // (undocumented)
    Type: FingerType;
}

// Warning: (ae-internal-missing-underscore) The name "RawHand" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class RawHand {
    // (undocumented)
    CurrentPrimary: boolean;
    // (undocumented)
    Fingers: RawFinger[];
    // (undocumented)
    WristPosition: Vector;
    // (undocumented)
    WristWidth: number;
}

// @internal
class ResponseCallback extends TouchFreeRequestCallback<WebSocketResponse> {
}

// @internal
class ServiceConnection {
    constructor(_ip?: string, _port?: string);
    Disconnect: () => void;
    get handshakeComplete(): boolean;
    OnMessage: (_message: MessageEvent) => void;
    QuickSetupRequest: (atTopTarget: boolean, _callback: (detail: WebSocketResponse) => void, _configurationCallback: (detail: ConfigState) => void) => void;
    RequestConfigFile: (_callback: (detail: ConfigState) => void) => void;
    RequestConfigState: (_callback: (detail: ConfigState) => void) => void;
    RequestServiceStatus: (_callback: (detail: ServiceStatus) => void) => void;
    RequestTrackingChange: (_state: Partial<TrackingState>, _callback: ((detail: TrackingStateResponse) => void) | null) => void;
    RequestTrackingState: (_callback: (detail: TrackingStateResponse) => void) => void;
    SendMessage: <T extends WebSocketResponse>(_message: string, _requestID: string, _callback: ((detail: WebSocketResponse | T) => void) | null) => void;
    get touchFreeVersion(): string;
    webSocket: WebSocket;
}

// Warning: (ae-incompatible-release-tags) The symbol "ServiceStatus" is marked as @public, but its signature references "TouchFreeRequest" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "ServiceStatus" is marked as @public, but its signature references "TouchFreeRequest" which is marked as @internal
//
// @public
class ServiceStatus extends TouchFreeRequest {
    constructor(_id: string, _trackingServiceState: TrackingServiceState | null, _configurationState: ConfigurationState | null);
    configurationState: ConfigurationState | null;
    trackingServiceState: TrackingServiceState | null;
}

// @internal
class ServiceStatusCallback extends TouchFreeRequestCallback<ServiceStatus> {
}

// @internal
class ServiceStatusRequest extends TouchFreeRequest {
}

// @internal
class SimpleRequest {
    constructor(_id: string);
    requestID: string;
}

// @internal
interface SuccessWrapper<T> {
    content?: T;
    msg: string;
    succeeded: boolean;
}

// @public
class SVGCursor extends TouchlessCursor {
    constructor(_ringSizeMultiplier?: number, _darkCursor?: boolean);
    // @internal
    HandleInputAction(_inputData: TouchFreeInputAction): void;
    HideCursor(): void;
    ShowCursor(): void;
    // @internal
    UpdateCursor(_inputAction: TouchFreeInputAction): void;
}

// @public
export interface TfInitParams {
    // (undocumented)
    initialiseCursor?: boolean;
}

// @public
const TouchFree: {
    CurrentCursor: TouchlessCursor | undefined;
    InputController: WebInputController | undefined;
    Init: (_tfInitParams?: TfInitParams) => void;
    IsConnected: () => boolean;
    RegisterEventCallback: <TEvent extends TouchFreeEvent>(event: TEvent, callback: TouchFreeEventSignatures[TEvent]) => EventHandle;
};
export { TouchFree }
export default TouchFree;

// @public
export type TouchFreeEvent = Extract<keyof TouchFreeEventSignatures, string>;

// @public
export interface TouchFreeEventSignatures {
    HandFound: () => void;
    HandsLost: () => void;
    InputAction: (inputAction: TouchFreeInputAction) => void;
    OnConnected: () => void;
    OnTrackingServiceStateChange: (state: TrackingServiceState) => void;
    // @internal
    TransmitHandData: (data: HandFrame) => void;
    TransmitInputAction: (inputAction: TouchFreeInputAction) => void;
    TransmitInputActionRaw: (inputAction: TouchFreeInputAction) => void;
    WhenConnected: () => void;
}

// @public
export class TouchFreeInputAction {
    constructor(_timestamp: number, _interactionType: InteractionType, _handType: HandType, _handChirality: HandChirality, _inputType: InputType, _cursorPosition: Array<number>, _distanceFromScreen: number, _progressToClick: number);
    // (undocumented)
    Chirality: HandChirality;
    // (undocumented)
    CursorPosition: Array<number>;
    // (undocumented)
    DistanceFromScreen: number;
    // (undocumented)
    HandType: HandType;
    // (undocumented)
    InputType: InputType;
    // (undocumented)
    InteractionType: InteractionType;
    // (undocumented)
    ProgressToClick: number;
    // (undocumented)
    Timestamp: number;
}

// @internal
abstract class TouchFreeRequest {
    constructor(_requestID: string);
    // (undocumented)
    requestID: string;
}

// @internal
abstract class TouchFreeRequestCallback<T> {
    constructor(_timestamp: number, _callback: (detail: T) => void);
    callback: (detail: T) => void;
    timestamp: number;
}

// @public
abstract class TouchlessCursor {
    constructor(_cursor: HTMLElement | SVGElement | undefined);
    cursor: HTMLElement | SVGElement | undefined;
    DisableCursor(): void;
    EnableCursor(): void;
    enabled: boolean;
    HandleInputAction(_inputAction: TouchFreeInputAction): void;
    HideCursor(): void;
    shouldShow: boolean;
    ShowCursor(): void;
    UpdateCursor(_inputAction: TouchFreeInputAction): void;
}

// @public
interface TouchPlaneInteractionSettings {
    TouchPlaneActivationDistanceCm: number;
    TouchPlaneTrackedPosition: TrackedPosition;
}

// @public
enum TrackedPosition {
    INDEX_STABLE = 0,
    INDEX_TIP = 1,
    NEAREST = 3,
    WRIST = 2
}

declare namespace Tracking {
    export {
        TrackingManager,
        Mask,
        TrackingState
    }
}
export { Tracking }

// @public
class TrackingManager {
    static ConvertResponseToState(_response: TrackingStateResponse): Partial<TrackingState>;
    static RequestTrackingChange(_state: Partial<TrackingState>, _callback?: ((detail: TrackingStateResponse) => void) | null): void;
    static RequestTrackingState(_callback: (detail: TrackingStateResponse) => void): void;
}

// @public
export enum TrackingServiceState {
    CONNECTED = 2,
    NO_CAMERA = 1,
    UNAVAILABLE = 0
}

// @public
class TrackingState {
    constructor(_mask: Mask, _cameraReversed: boolean, _allowImages: boolean, _analyticsEnabled: boolean);
    allowImages: boolean;
    analyticsEnabled: boolean;
    cameraReversed: boolean;
    mask: Mask;
}

// @internal
class TrackingStateCallback {
    constructor(_timestamp: number, _callback: (detail: TrackingStateResponse) => void);
    callback: (detail: TrackingStateResponse) => void;
    timestamp: number;
}

// @internal
class TrackingStateRequest {
    constructor(_id: string, _mask: Mask, _cameraReversed: boolean, _allowImages: boolean, _analyticsEnabled: boolean);
    allowImages: boolean;
    analyticsEnabled: boolean;
    cameraReversed: boolean;
    mask: Mask;
    requestID: string;
}

// @public
interface TrackingStateResponse {
    // Warning: (ae-incompatible-release-tags) The symbol "allowImages" is marked as @public, but its signature references "SuccessWrapper" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "allowImages" is marked as @public, but its signature references "SuccessWrapper" which is marked as @internal
    allowImages: SuccessWrapper<boolean> | null;
    // Warning: (ae-incompatible-release-tags) The symbol "analyticsEnabled" is marked as @public, but its signature references "SuccessWrapper" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "analyticsEnabled" is marked as @public, but its signature references "SuccessWrapper" which is marked as @internal
    analyticsEnabled: SuccessWrapper<boolean> | null;
    // Warning: (ae-incompatible-release-tags) The symbol "cameraReversed" is marked as @public, but its signature references "SuccessWrapper" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "cameraReversed" is marked as @public, but its signature references "SuccessWrapper" which is marked as @internal
    cameraReversed: SuccessWrapper<boolean> | null;
    // Warning: (ae-incompatible-release-tags) The symbol "mask" is marked as @public, but its signature references "SuccessWrapper" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "mask" is marked as @public, but its signature references "SuccessWrapper" which is marked as @internal
    mask: SuccessWrapper<Mask> | null;
    requestID: string;
}

declare namespace Utilities {
    export {
        MapRangeToRange
    }
}
export { Utilities }

// @public
interface Vector {
    X: number;
    Y: number;
    Z: number;
}

// @public
interface Vector2 {
    x: number;
    y: number;
}

// @public
class VersionHandshakeResponse extends WebSocketResponse {
    constructor(_id: string, _status: string, _msg: string, _request: string, _touchFreeVersion: string, _apiVersion: string);
    apiVersion: string;
    touchFreeVersion: string;
}

// Warning: (ae-internal-missing-underscore) The name "VersionInfo" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class VersionInfo {
    static readonly API_HEADER_NAME: string;
    static readonly ApiVersion: string;
}

// @public
class WebInputController extends BaseInputController {
    constructor();
    enterLeaveEnabled: boolean;
    // @internal
    protected HandleInputAction(_inputData: TouchFreeInputAction): void;
    // @internal
    HandleMove(_element: Element | null): void;
}

// Warning: (ae-internal-missing-underscore) The name "WebsocketInputAction" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class WebsocketInputAction {
    constructor(_timestamp: number, _interactionFlags: BitmaskFlags, _cursorPosition: Vector2, _distanceFromScreen: number, _progressToClick: number);
    CursorPosition: Vector2;
    DistanceFromScreen: number;
    InteractionFlags: BitmaskFlags;
    ProgressToClick: number;
    Timestamp: number;
}

// Warning: (ae-incompatible-release-tags) The symbol "WebSocketResponse" is marked as @public, but its signature references "TouchFreeRequest" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "WebSocketResponse" is marked as @public, but its signature references "TouchFreeRequest" which is marked as @internal
//
// @public
class WebSocketResponse extends TouchFreeRequest {
    constructor(_id: string, _status: string, _msg: string, _request: string);
    message: string;
    originalRequest: string;
    status: string;
}

```
